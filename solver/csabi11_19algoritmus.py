# -*- coding: utf-8 -*-
"""csabi11.19algoritmus.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zgslskItVSr_vNVK_ef-lxri6kKltyev
"""

import random
import numpy as np

import pygame
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GLU import *


class Cubie:

    def __init__(self,x=[-1,-1,-1]): # x y z irányban a színek
        self.l=np.array(x)

    def RL(self):
        # print("t")
        # füzetben ábra, z küröl forgatás, azaz első index helyén marad, másik 2 csere
        # kérdés az, hogy ez lehet-e jó reprezentáció cubiera? él, sarok forgatás vizualizáció úgy, hogy
        # a hiányzó színek -1 esek?
        self.l
        self.l[[1,2]]=self.l[[2,1]]  # x körüli forgatás, ez az R és L is, R' L' is

    def UD(self):
      self.l
      self.l[[0,2]]=self.l[[2,0]]

    def FB(self):
      self.l
      self.l[[0,1]]=self.l[[1,0]]

    def __str__(self):
        return str(self.l)

class Cube:

    def __init__(self,x=[[[str(k)+str(j)+str(i) for i in range(3)] for j in range(3)]for k in range(3)]): # ide kell immutabel inicializálás, fix tárhely miatt
        self.historystring = ""
        self.l=np.array(x) #itt ha self.l=x volt akkor az a mindegyiknél létrejövő x=np.array([[[]]]) re mutatott?
        self.dict_of_num_cubie={}
        self.dict_of_cubie_num={}

        for i in range(3):
            for j in range(3):
                for k in range(3):
                    self.dict_of_num_cubie[str(i)+str(j)+str(k)]=Cubie()

    def __str__(self):
        return str(self.l)

    def X_to_Y(self): #a numpy array-t átkonvertálja X szerinti rétegződésből Y szerinti rétegződésbe

      self.l[0,[0,2],:]=self.l[0,[2,0], :]
      self.l[[0,2], 0, :]=self.l[[2,0], 0, :]
      self.l[0,[0,1],:]=self.l[0,[1,0], :]
      self.l[[0,1], 0, :]=self.l[[1,0], 0, :]
      self.l[0,[0,2],:]=self.l[0,[2,0], :]
      self.l[0,[1,2],:]=self.l[0,[2,1], :]
      self.l[2,[0,1],:]=self.l[2,[1,0], :]
      self.l[1,[0,2],:]=self.l[1,[2,0], :]
      self.l[[1,2], 0, :]=self.l[[2,1], 0, :]
      self.l[1,[0,2],:]=self.l[1,[2,0], :]
      self.l[2,[0,1],:]=self.l[2,[1,0], :]

    def Y_to_X(self): #a numpy array-t átkonvertálja Y szerinti rétegződésből X szerinti rétegződésbe

      self.l[0,[0,1],:]=self.l[0,[1,0],:]
      self.l[[0,1],0,:]=self.l[[1,0], 0,:]
      self.l[0,[0,1],:]=self.l[0,[1,0],:]
      self.l[0,[0,2],:]=self.l[0,[2,0],:]
      self.l[[0,2],0,:]=self.l[[2,0],0,:]
      self.l[0,[0,2],:]=self.l[0,[2,0],:]
      self.l[1,[0,2],:]=self.l[1,[2,0],:]
      self.l[2,[0,1],:]=self.l[2,[1,0],:]
      self.l[[1,2],0,:]=self.l[[2,1],0,:]
      self.l[2,[0,1],:]=self.l[2,[1,0],:]
      self.l[1,[0,2],:]=self.l[1,[2,0],:]

    def X_to_Z(self): #a numpy array-t átkonvertálja X szerinti rétegződésből Z szerinti rétegződésbe

      self.l[0,:,[0,2]]=self.l[0,:,[2,0]]
      self.l[[0,2],:,0]=self.l[[2,0],:,0]
      self.l[0,:,[0,1]]=self.l[0,:,[1,0]]
      self.l[[0,1], :, 0]=self.l[[1,0],:, 0]
      self.l[0,:,[0,2]]=self.l[0,:,[2,0]]
      self.l[0,:,[1,2]]=self.l[0,:,[2,1]]
      self.l[2,:,[0,1]]=self.l[2,:,[1,0]]
      self.l[1,:,[0,2]]=self.l[1,:,[2,0]]
      self.l[[1,2],:, 0]=self.l[[2,1],:,0]
      self.l[1,:,[0,2]]=self.l[1,:,[2,0]]
      self.l[2,:,[0,1]]=self.l[2,:,[1,0]]

    def Z_to_X(self): #a numpy array-t átkonvertálja Z szerinti rétegződésből X szerinti rétegződésbe

      self.l[0,:,[0,1]]=self.l[0,:,[1,0]]
      self.l[[0,1],:,0]=self.l[[1,0],:,0]
      self.l[0,:,[0,1]]=self.l[0,:,[1,0]]
      self.l[0,:,[0,2]]=self.l[0,:,[2,0]]
      self.l[[0,2],:,0]=self.l[[2,0],:,0]
      self.l[0,:,[0,2]]=self.l[0,:,[2,0]]
      self.l[1,:,[0,2]]=self.l[1,:,[2,0]]
      self.l[2,:,[0,1]]=self.l[2,:,[1,0]]
      self.l[[1,2],:,0]=self.l[[2,1],:,0]
      self.l[2,:,[0,1]]=self.l[2,:,[1,0]]
      self.l[1,:,[0,2]]=self.l[1,:,[2,0]]

    def converter(to_what,self): #swtich
        pass

    def R(self): # x y z koordináták, z=0 front, x=2 right

        self.historystring += "R"
        for i in self.l[2,:,:]:
            for j in i:
                #print(j)
                self.dict_of_num_cubie[j].RL() # minden forgatott cubie saját helyzetét is megváltoztatja

        self.l[2,:,:]=self.l[2,:,:].transpose() # jobbra forg T aztán oszlopcsere
        self.l[2,:,[0,2]]=self.l[2,:,[2,0]]

    def L(self):

        self.historystring += "L"
        for i in self.l[0,:,:]:
            for j in i:
                #print(j)
                self.dict_of_num_cubie[j].RL() # minden forgatott cubie saját helyzetét is megváltoztatja

        self.l[0,:,:]=self.l[0,:,:].transpose() # jobbra forg T aztán oszlopcsere
        self.l[0,:,[2,0]]=self.l[0,:,[0,2]]

    def U(self):

      self.historystring += "U"
      self.X_to_Y()

      for i in self.l[0,:,:]:
            for j in i:
                #print(j)
                self.dict_of_num_cubie[j].UD()

      self.l[0,:,:]=self.l[0,:,:].transpose() # jobbra forg T aztán oszlopcsere
      self.l[0,:,[2,0]]=self.l[0,:,[0,2]]

      self.Y_to_X()

    def D(self):

      self.historystring += "D"
      self.X_to_Y()

      for i in self.l[2,:,:]:
            for j in i:
                #print(j)
                self.dict_of_num_cubie[j].UD()

      self.l[2,:,:]=self.l[2,:,:].transpose() # jobbra forg T aztán oszlopcsere
      self.l[2,:,[0,2]]=self.l[2,:,[2,0]]

      self.Y_to_X()

    def F(self):

      self.historystring += "F"
      self.X_to_Z()

      for i in self.l[0,:,:]:
            for j in i:
                #print(j)
                self.dict_of_num_cubie[j].FB()

      self.l[0,:,:]=self.l[0,:,:].transpose() # jobbra forg T aztán oszlopcsere
      self.l[0,:,[0,2]]=self.l[0,:,[2,0]]

      self.Z_to_X()

    def B(self):

      self.historystring += "B"
      self.X_to_Z()

      for i in self.l[2,:,:]:
            for j in i:
                #print(j)
                self.dict_of_num_cubie[j].FB()

      self.l[2,:,:]=self.l[2,:,:].transpose() # jobbra forg T aztán oszlopcsere
      self.l[2,:,[2,0]]=self.l[2,:,[0,2]]

      self.Z_to_X()

    def R_r(self):

      for i in range(3):
        self.R()

    def L_r(self):

      for i in range(3):
        self.L()

    def U_r(self):

      for i in range(3):
        self.U()

    def D_r(self):

      for i in range(3):
        self.D()

    def F_r(self):

      for i in range(3):
        self.F()

    def B_r(self):

      for i in range(3):
        self.B()

    def cube_method_mixer(self,steps=20):
    # ebbe jöhet stringsorozat vagy szám
      if type(steps)==int:
          for i in range(steps):
            a=random.randint(1,12)
            if a==1:
              self.R()
            if a==2:
              self.L()
            if a==3:
              self.U()
            if a==4:
              self.D()
            if a==5:
              self.F()
            if a==6:
              self.B()
            if a==7:
              self.R_r()
            if a==8:
              self.L_r()
            if a==9:
              self.U_r()
            if a==10:
              self.D_r()
            if a==11:
              self.F_r()
            if a==12:
              self.B_r()
      else:
          for current_step_string in steps:
            if current_step_string=="R":
                self.R()
            if current_step_string=="L":
                self.L()
            if current_step_string=="U":
                self.U()
            if current_step_string=="D":
                self.D()
            if current_step_string=="F":
                self.F()
            if current_step_string=="B":
                self.B()
            if current_step_string=="r":
                self.R_r()
            if current_step_string=="l":
                self.L_r()
            if current_step_string=="u":
                self.U_r()
            if current_step_string=="d":
                self.D_r()
            if current_step_string=="f":
                self.F_r()
            if current_step_string=="b":
                self.B_r()
            if current_step_string == "x":
                self.cube_method_flipper("x")
            if current_step_string == "y":
                self.cube_method_flipper("y")

    def cube_method_all_side_loader(self,string="".join(["W"*9,"Y"*9,"O"*9,"G"*9,"R"*9,"B"*9])):
        # alapállapotba betölti a kockát
        sorrend="UDLFRB"
        sides=[
        self.l[:,0,:], # U 3 W
        self.l[:,2,:], # D 2 Y
        self.l[0,:,:], # L 5 O
        self.l[:,:,0], # F 6 G
        self.l[2,:,:], # R 1 R
        self.l[:,:,2], # B 4 B
        ]

        tuples_of_strings=[]
        counter_of_sides=0
        for i in range(0,len(string),9):
            #print(string[i:i+9])
            tuples_of_strings.append((string[i:i+9],sorrend[counter_of_sides],sides[counter_of_sides]))
            counter_of_sides+=1
            #print(tuples_of_strings)
            # minde 3 koord lehet 0 1 2 ez 3*3*3 aza 27 koord amik a cubiek
            # oldalak:x - 0:: , 2::
            #    z- ::0 ::2

        dict_of_num_color={1: "R", 2:"Y",3:"W", 4:"B", 5:"O", 6:"G"}
        dict_of_color_num={"R":1, "Y":2,"W":3, "B":4, "O":5, "G":6}

        index=0

        for i in sides: #
            ninestring=tuples_of_strings[index][0]
            #print(ninestring)
            #index+=1
            # i a sor
            #print(i)
            stringindex=0
            for j in i:
                for k in j:
                # j az elem
                    #print(k)
                    #print(cube.dict_of_num_cubie[j])
                    if tuples_of_strings[index][1]=="U" or tuples_of_strings[index][1]=="D":
                        self.dict_of_num_cubie[k].l[1]=dict_of_color_num[ninestring[stringindex]] # 0 mert a cubie 0.eleme az x koord,
                    if tuples_of_strings[index][1]=="R" or tuples_of_strings[index][1]=="L":
                        self.dict_of_num_cubie[k].l[0]=dict_of_color_num[ninestring[stringindex]] # 0 mert a cubie 0.eleme az x koord,
                    if tuples_of_strings[index][1]=="F" or tuples_of_strings[index][1]=="B":
                        self.dict_of_num_cubie[k].l[2]=dict_of_color_num[ninestring[stringindex]] # 0 mert a cubie 0.eleme az x koord,

                    #print(self.dict_of_num_cubie[k])
                    #cube.dict_of_num_cubie[j].L()
                    #print(cube.dict_of_num_cubie[j])
                    stringindex+=1
            index+=1
            #print(dict_of_num_cubie[j])

    def vertices_of_all_cubies_maker(self):
        # listát gyárt a 3d kiíratáshoz, ezt saját self.vertices_of_all_cubies attr-ba menti
        counter=0
        list_of_touples=[]

        for i in self.l[:,:,:]: # x=2 re nézzük= R oldal
            # i a sor
            for j in i:
                # j az elem
                for k in j:
                    list_of_touples.append((counter,self.dict_of_num_cubie[k].l))
                    counter+=1


        vertices= (
            (1, -1, -1),
            (1, 1, -1),
            (-1, 1, -1),
            (-1, -1, -1),
            (1, -1, 1),
            (1, 1, 1),
            (-1, -1, 1),
            (-1, 1, 1)
            )

        vertices16=tuple([tuple([vertex[0]+2,vertex[1]+2,vertex[2]-2])for vertex in vertices ])
        vertices25=tuple([tuple([vertex[0]+2,vertex[1]+2,vertex[2]])for vertex in vertices ])
        vertices21=tuple([tuple([vertex[0]+2,vertex[1]+2,vertex[2]+2])for vertex in vertices ])

        vertices10=tuple([tuple([vertex[0]+2,vertex[1],vertex[2]-2])for vertex in vertices ])
        vertices5=tuple([tuple([vertex[0]+2,vertex[1],vertex[2]])for vertex in vertices ])
        vertices27=tuple([tuple([vertex[0]+2,vertex[1],vertex[2]+2])for vertex in vertices ])

        vertices14=tuple([tuple([vertex[0]+2,vertex[1]-2,vertex[2]-2])for vertex in vertices ])
        vertices8=tuple([tuple([vertex[0]+2,vertex[1]-2,vertex[2]])for vertex in vertices ])
        vertices15=tuple([tuple([vertex[0]+2,vertex[1]-2,vertex[2]+2])for vertex in vertices ])

        # ez az x[0] az x[:::] sorrendben

        vertices23=tuple([tuple([vertex[0],vertex[1]+2,vertex[2]-2])for vertex in vertices ])
        vertices3=tuple([tuple([vertex[0],vertex[1]+2,vertex[2]])for vertex in vertices ])
        vertices12=tuple([tuple([vertex[0],vertex[1]+2,vertex[2]+2])for vertex in vertices ])

        vertices7=tuple([tuple([vertex[0],vertex[1],vertex[2]-2])for vertex in vertices ])
        #vertices
        vertices4=tuple([tuple([vertex[0],vertex[1],vertex[2]+2])for vertex in vertices ])

        vertices9=tuple([tuple([vertex[0],vertex[1]-2,vertex[2]-2])for vertex in vertices ])
        vertices6=tuple([tuple([vertex[0],vertex[1]-2,vertex[2]])for vertex in vertices ])
        vertices26=tuple([tuple([vertex[0],vertex[1]-2,vertex[2]+2])for vertex in vertices ])

        # ez az x[1] az x[:::] sorrendben

        vertices19=tuple([tuple([vertex[0]-2,vertex[1]+2,vertex[2]-2])for vertex in vertices ])
        vertices11=tuple([tuple([vertex[0]-2,vertex[1]+2,vertex[2]])for vertex in vertices ])
        vertices18=tuple([tuple([vertex[0]-2,vertex[1]+2,vertex[2]+2])for vertex in vertices ])

        vertices24=tuple([tuple([vertex[0]-2,vertex[1],vertex[2]-2])for vertex in vertices ])
        vertices2=tuple([tuple([vertex[0]-2,vertex[1],vertex[2]])for vertex in vertices ])
        vertices13=tuple([tuple([vertex[0]-2,vertex[1],vertex[2]+2])for vertex in vertices ])

        vertices17=tuple([tuple([vertex[0]-2,vertex[1]-2,vertex[2]-2])for vertex in vertices ])
        vertices22=tuple([tuple([vertex[0]-2,vertex[1]-2,vertex[2]])for vertex in vertices ])
        vertices20=tuple([tuple([vertex[0]-2,vertex[1]-2,vertex[2]+2])for vertex in vertices ])

        self.vertices_of_all_cubies=[vertices16,
                                vertices25,
                                vertices21,

                                vertices10,
                                vertices5,
                                vertices27,

                                vertices14,
                                vertices8,
                                vertices15,

                                vertices23,
                                vertices3,
                                vertices12,

                                vertices7,
                                vertices,
                                vertices4,

                                vertices9,
                                vertices6,
                                vertices26,

                                vertices19,
                                vertices11,
                                vertices18,

                                vertices24,
                                vertices2,
                                vertices13,

                                vertices17,
                                vertices22,
                                vertices20

                               ]

    def Cube_3d(self,verticesl,colornumsl):

        edges = ((0,1),
         (0,3),
         (0,4),
         (2,1),
         (2,3),
         (2,7),
         (6,3),
         (6,4),
         (6,7),
         (5,1),
         (5,4),
         (5,7))

        surfaces = ((3, 2, 7, 6), #xyz xyz
                    (1, 5, 7, 2),
                    (0, 1, 2, 3),

                    (4, 5, 1, 0),
                    (4, 0, 3, 6),
                    (6, 7, 5, 4),)

        dict_of_num_color={1: "R", 2:"Y",3:"W", 4:"B", 5:"O", 6:"G"}
        dict_of_color_num={"R":1, "Y":2,"W":3, "B":4, "O":5, "G":6}
        dict_of_colornum_rbg={1: (256, 0, 0), 2:(256, 256, 0),3:(256, 256, 256), 4:(0, 0, 256), 5:(0, 0, 0), 6:(0, 256, 0)}

        colors = ((1, 0, 0), # red
                  (0, 1, 0), # green
                  (252, 173, 3), #orange
                  (1, 1, 0), #yellow
                  (256, 256, 256), # white
                  (0, 0, 1)) # blue

        glBegin(GL_QUADS)

        cnum=2
        for surface in surfaces:
            cnum+=1
            cnum=cnum%3

            for vertex in surface:

                if colornumsl[cnum] in dict_of_colornum_rbg.keys():
                    glColor3fv(dict_of_colornum_rbg[colornumsl[cnum]])
                else:

                    glColor3fv((252,0,210))
                glVertex3fv(verticesl[vertex])

        glEnd()

        glBegin(GL_LINES) # line-drawing code
        for edge in edges:
            for vertex in edge:
                glVertex3fv(verticesl[vertex]) # sorban a pontok minden élre
        glEnd()

    def cube_method_3d_drawer(self,string_of_steps=None):
        pygame.init()
        display = (800,600)
        pygame.display.set_mode(display, DOUBLEBUF|OPENGL)
        gluPerspective(45, (display[0]/display[1]), 0.1, 50.0)
        glTranslatef(0.0,0.0, -20) # z irábyan -5 move a kamerának, hogy lássuk a kockát
        glRotatef(25, 2, 1, 0)

        steps_current_pos=0 # ennek majd meg kell írni hogy ha out of range a string_of_stepsben akkor csak =None és csá, tovább megy a loop simán
        while True:

            if string_of_steps!=None:
                # kell egy léptető a nyilakkal
                pygame.time.wait(500)
                current_step_string=string_of_steps[steps_current_pos]
                if current_step_string=="R":
                    self.R()
                if current_step_string=="L":
                    self.L()
                if current_step_string=="U":
                    self.U()
                if current_step_string=="D":
                    self.D()
                if current_step_string=="F":
                    self.F()
                if current_step_string=="B":
                    self.B()
                if current_step_string=="r":
                    self.R_r()
                if current_step_string=="l":
                    self.L_r()
                if current_step_string=="u":
                    self.U_r()
                if current_step_string=="d":
                    self.D_r()
                if current_step_string=="f":
                    self.F_r()
                if current_step_string=="b":
                    self.B_r()
                pygame.time.wait(1000)
                steps_current_pos+=1

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    print("quit")
                    pygame.display.quit()

                    pygame.quit()

                if event.type == pygame.KEYDOWN:
                    #pygame.time.Clock.tick(120)
                    # UDLFRB
                    if event.key == pygame.K_x:
                        self.cube_method_flipper("x")
                    if event.key == pygame.K_y:
                        self.cube_method_flipper("y")
                    if event.key == pygame.K_u:
                        self.U()
                    if event.key == pygame.K_d:
                        self.D()
                    if event.key == pygame.K_f:
                        self.F()
                    if event.key == pygame.K_b:
                        self.B()
                    if event.key == pygame.K_l:
                        self.L()
                    if event.key == pygame.K_r:
                        self.R()

                    if event.key == pygame.K_SPACE:
                        pygame.quit()
                    if event.key == pygame.K_LEFT:
                        glTranslatef(-0.5,0,0)
                    if event.key == pygame.K_RIGHT:
                        glTranslatef(0.5,0,0)

                    if event.key == pygame.K_UP:
                        glTranslatef(0,1,0)
                    if event.key == pygame.K_DOWN:
                        glTranslatef(0,-1,0)
                if event.type == pygame.MOUSEMOTION:
                    mouseMove = pygame.mouse.get_rel()
                    #glRotatef(mouseMove[0]*0.1, 0.0, 1.0, 0.0)
                    glRotatef(mouseMove[0]*0.1, 0.0, 1.0, 0.0)
                    #glRotatef(1.0, mouseMove[1]*0.1, 1.0, 0.0)

                if event.type == pygame.MOUSEBUTTONDOWN:
                    if event.button == 4:
                        glTranslatef(0,0,1.0)

                    if event.button == 5:
                        glTranslatef(0,0,-1.0)


            #glRotatef(1, 1, 1, 1)
            glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT) # clear

            glEnable (GL_DEPTH_TEST)
            num_of_colors=6

            counter=0
            list_of_touples=[]

            for i in self.l[:,:,:]: # x=2 re nézzük= R oldal
                # i a sor
                for j in i:
                    # j az elem
                    for k in j:
                        list_of_touples.append((counter,self.dict_of_num_cubie[k].l))
                        counter+=1

            self.vertices_of_all_cubies_maker()

            for tup in list_of_touples:
                vertices=self.vertices_of_all_cubies[tup[0]]
                chosen_tree=tup[1]
                self.Cube_3d(vertices,chosen_tree)

            pygame.display.flip() # updates the display
            pygame.time.wait(10) # wait?

        self.cube_method_3d_drawer()
        #test

    def cube_method_flipper(self,dir_of_flip="x"):
        '''Input x vagy z szerint forgatja az egész kockát  '''
        if dir_of_flip=="x":
            self.historystring += "x"
            # def R(self): # x y z koordináták, z=0 front, x=2 right
            for i in self.l[:,:,:]:
                # print(i)
                for j in i:
                    # print(j)
                    for k in j:
                        # print(k)
                        self.dict_of_num_cubie[k].RL() # minden forgatott cubie saját helyzetét is megváltoztatja

            self.l[2,:,:]=self.l[2,:,:].transpose() # jobbra forg T aztán oszlopcsere
            self.l[2,:,[0,2]]=self.l[2,:,[2,0]]

            self.l[1,:,:]=self.l[1,:,:].transpose() # jobbra forg T aztán oszlopcsere
            self.l[1,:,[0,2]]=self.l[1,:,[2,0]]

            self.l[0,:,:]=self.l[0,:,:].transpose() # jobbra forg T aztán oszlopcsere
            self.l[0,:,[0,2]]=self.l[0,:,[2,0]]

        if dir_of_flip=="y":
            self.historystring += "y"
            # def R(self): # x y z koordináták, z=0 front, x=2 right
            for i in self.l[:,:,:]:
                # print(i)
                for j in i:
                    # print(j)
                    for k in j:
                        # print(k)
                        self.dict_of_num_cubie[k].UD() # minden forgatott cubie saját helyzetét is megváltoztatja

            self.l[:,2,:]=self.l[:,2,:].transpose() # jobbra forg T aztán oszlopcsere
            self.l[:,2,[0,2]]=self.l[:,2,[2,0]]

            self.l[:,1,:]=self.l[:,1,:].transpose() # jobbra forg T aztán oszlopcsere
            self.l[:,1,[0,2]]=self.l[:,1,[2,0]]

            self.l[:,0,:]=self.l[:,0,:].transpose() # jobbra forg T aztán oszlopcsere
            self.l[:,0,[0,2]]=self.l[:,0,[2,0]]

    def cube_method_one_char_to_move(self,current_step_string):
        '''Bejön egy karakter és megcsinálja belőle a lépést, x y flipre is működik'''
        if current_step_string=="R":
            self.R()
        if current_step_string=="L":
            self.L()
        if current_step_string=="U":
            self.U()
        if current_step_string=="D":
            self.D()
        if current_step_string=="F":
            self.F()
        if current_step_string=="B":
            self.B()
        if current_step_string=="r":
            self.R_r()
        if current_step_string=="l":
            self.L_r()
        if current_step_string=="u":
            self.U_r()
        if current_step_string=="d":
            self.D_r()
        if current_step_string=="f":
            self.F_r()
        if current_step_string=="b":
            self.B_r()
        if current_step_string=="x":
            self.cube_method_flipper('x')
        if current_step_string=="y":
            self.cube_method_flipper('y')

    def cube_method_get_cubie_pos_name_color(self):
        '''visszadob egy listet amiben tupleként vannak a
        (kockakoord, ottlévő cubie string,cubie.l) alakban a lekérdezés pillanatában!!
        '''
        list_of_tuples=[]
        firstkoord=0
        for i in self.l:
            secondkoord=0
            for j in i:
                thirdkoord=0
                for k in j:
                    # print(k)
                    # print([firstkoord,secondkoord,thirdkoord])
                    list_of_tuples.append(([firstkoord,secondkoord,thirdkoord],k,self.dict_of_num_cubie[k].l))
                    thirdkoord+=1
                secondkoord+=1
            firstkoord+=1
        return list_of_tuples

    def cube_method_did_cubie_move(self,current_step_string,cubieposnum):
        '''Input egy step string pl F,R stb és egy cubie location,
        a fgv megmondja, hogy a lépés hatására mozgott-e a cubie azon a posin
        tehát ezzel tudjuk ellenőrizni h egy adott cubie location mozog egy lépés hatására
        azaz pl 0 0 0 F-en van-e'''
        did_it_turn=False

        koord1=int(cubieposnum[0])
        koord2=int(cubieposnum[1])
        koord3=int(cubieposnum[2])

        temp=self.l[koord1][koord2][koord3]

        self.cube_method_one_char_to_move(current_step_string)

        if self.dict_of_num_cubie[cubieposnum].l!=temp:
            print('MOZDULT')
            did_it_turn=True
            self.cube_method_one_char_to_move(current_step_string)
            self.cube_method_one_char_to_move(current_step_string)
            self.cube_method_one_char_to_move(current_step_string)

        else:
            print('Nomove')

        return did_it_turn


def cube_method_findcolour(c, x=-1, y=-1, z=-1):
  l = c.cube_method_get_cubie_pos_name_color()
  for i in range(len(l)):
    if x == l[i][2][0] and y == l[i][2][1] and z == l[i][2][2]:
        a = l[i]
    if x == l[i][2][0] and y == l[i][2][2] and z == l[i][2][1]:
        a = l[i]
    if x == l[i][2][1] and y == l[i][2][0] and z == l[i][2][2]:
        a = l[i]
    if x == l[i][2][1] and y == l[i][2][2] and z == l[i][2][0]:
        a = l[i]
    if x == l[i][2][2] and y == l[i][2][1] and z == l[i][2][0]:
        a = l[i]
    if x == l[i][2][2] and y == l[i][2][0] and z == l[i][2][1]:
        a = l[i]
  return a 


def cube_method_good_orient(edge, x=-1, y=-1, z=-1):

    if edge[0] == x and edge[1] == y and edge[2] == z:

        return True
        
    else:

        return False

def cube_method_which_colour(c, string):
    l=c.cube_method_get_cubie_pos_name_color()
    for i in range(l):
      if l[i][1] == string:
        return l[i]

def yellow(c):
  l=c.cube_method_get_cubie_pos_name_color()
  yellow=l[18]
  for i in range(len(yellow[2])):
    if yellow[2][i]==2:
      return True

def first_row(c):
    l1 = c.cube_method_get_cubie_pos_name_color()
    fr=[]
    for i in range(len(l1)):
        if l1[i][0][1]==0:
            fr.append(l1[i])
    return fr

def check_first_row(check_cube,cube):
    fr=first_row(cube)
    check_fr=first_row(check_cube)
    check=True
    for i in range(len(fr)):
        if all(check_fr[i][2]==fr[i][2]) == False:
            check=False
            break
    if check:
        return (check, fr)
    else:
        return check

def white_cross_first(c, x=-1, y=3, z=4):
    first = cube_method_findcolour(c, x, y, z)
    if first[0][2] == 0:
    # z=0 oldal
        if first[0][1] == 0:

            #c.cube_method_mixer("UU")
            c.U()
            c.U()

        if first[0][1] == 1:

            if first[0][0] == 0:

                #c.cube_method_mixer("FUU")
                c.F()
                c.U()
                c.U()

            if first[0][0] == 2:

                # c.cube_method_mixer("fUU")
                c.F_r()
                c.U()
                c.U()

        if first[0][1] == 2:

            # c.cube_method_mixer("FFUU")
            c.F()
            c.F()
            c.U()
            c.U()

    if first[0][2] == 1: # z szerint 1

        if first[0][1] == 0: # y szerint 0

            if first[0][0] == 0: # x szerint 0

                c.U()

            if first[0][0] == 2:

                c.U_r()

        if first[0][1] == 2: # y szerint 2

            if first[0][0] == 0:

                # c.cube_method_mixer("LLU")
                c.L()
                c.L()
                c.U()

            if first[0][0] == 2:

                # c.cube_method_mixer("RRu")
                c.R()
                c.R()
                c.U_r()

    if first[0][2] == 2:

        if first[0][1] == 0:

            pass

        if first[0][1] == 1:

            if first[0][0] == 0:

                c.B_r()

            if first[0][0] == 2:

                c.B()

        if first[0][1] == 2:

            # c.cube_method_mixer("BB")
            c.B()
            c.B()

    if cube_method_good_orient(first[2], x, y, z) == True:

        return True

    else:

        # c.cube_method_mixer("Bru")
        c.B_r()
        c.R_r()
        c.U_r()

        return True

def white_cross_second(c, x=1, y=3, z=-1): # piros fehér
    second = cube_method_findcolour(c,x,y,z)
    if second[0][2] == 0:
            
        if second[0][1] == 0:

            # c.cube_method_mixer("FR")
            c.F()
            c.R()
      
        if second[0][1] == 1:

            if second[0][0] == 0:

                # c.cube_method_mixer("fdRR")
                c.F()
                c.F()
                c.R()

            if second[0][0] == 2:

                c.R()
            
        if second[0][1] == 2:

            # c.cube_method_mixer("dRR")
            c.F_r()
            c.R()
                
    if second[0][2] == 1:

        if second[0][1] == 0:

            if second[0][0] == 0:

                # c.cube_method_mixer("lFFR")
                c.L()
                c.F()
                c.F()
                c.R()

            if second[0][0] == 2:

                pass
            
        if second[0][1] == 2:

            if second[0][0] == 0:

                # c.cube_method_mixer("DDRR")
                c.D()
                c.D()
                c.R()
                c.R()
                
            if second[0][0] == 2:

                # c.cube_method_mixer("RR")
                c.R()
                c.R()

    if second[0][2] == 2:

        if second[0][1] == 0:

            pass

        if second[0][1] == 1:

            if second[0][0] == 0:

                # c.cube_method_mixer("LDDRR")
                c.L_r()
                c.D()
                c.D()
                c.R()
                c.R()


            if second[0][0] == 2:

                c.R_r()
            
        if second[0][1] == 2:

            # c.cube_method_mixer("DRR")
            c.D_r()
            c.R()
            c.R()


    if cube_method_good_orient(second[2], x, y, z) == True:

        return True
      
    else:

        # c.cube_method_mixer("rrDfR")
        c.R_r()
        c.R_r()
        c.D_r()
        c.F_r()
        c.R()


        return True

def white_cross_third(c, x=-1, y=3, z=6):
    third = cube_method_findcolour(c, x, y, z)
    if third[0][2] == 0:
            
        if third[0][1] == 0:

            pass
      
        if third[0][1] == 1:

            if third[0][0] == 0:
                  
                c.F()
                  
            if third[0][0] == 2:

                c.F_r()
            
        if third[0][1] == 2:

            # c.cube_method_mixer("FF")
            c.F()
            c.F()
                
    if third[0][2] == 1:

        if third[0][1] == 0:

            if third[0][0] == 0:

                # c.cube_method_mixer("lF")
                c.L()
                c.F()

            if third[0][0] == 2:

                pass

        if third[0][1] == 2:

            if third[0][0] == 0:

                # c.cube_method_mixer("dFF")
                c.D()
                c.F()
                c.F()
                
            if third[0][0] == 2:

                # c.cube_method_mixer("DFF")
                c.D_r()
                c.F()
                c.F()

    if third[0][2] == 2:

        if third[0][1] == 0:
            pass

        if third[0][1] == 1:

            if third[0][0] == 0:

                # c.cube_method_mixer("LdFF")
                c.L_r()
                c.D()
                c.F()
                c.F()

            if third[0][0] == 2:

                # c.cube_method_mixer("RDrFF")
                c.R()
                c.D_r()
                c.R_r()
                c.F()
                c.F()
            
        if third[0][1] == 2:

            # c.cube_method_mixer("DDFF")
            c.D()
            c.D()
            c.F()
            c.F()

    if cube_method_good_orient(third[2], x, y, z) == True:

        return True
      
    else:

        # c.cube_method_mixer("fldFF")
        c.F_r()
        c.L()
        c.D()
        c.F()
        c.F()


        return True

def white_cross_fourth(c, x=5, y=3, z=-1):
    fourth = cube_method_findcolour(c, x, y, z)
    if fourth[0][2] == 0:
            
        if fourth[0][1] == 0:
              
            pass
      
        if fourth[0][1] == 1:

            if fourth[0][0] == 0:
                  
                c.L_r()
                  
            if fourth[0][0] == 2:

                # c.cube_method_mixer("fflFF")
                c.F_r()
                c.F_r()
                c.L_r()
                c.F()
                c.F()
            
        if fourth[0][1] == 2:

            # c.cube_method_mixer("DLL")
            c.D_r()
            c.L()
            c.L()
                
    if fourth[0][2] == 1:

        if fourth[0][1] == 0:

            if fourth[0][0] == 0:

                pass

            if fourth[0][0] == 2:
                  
                pass

        if fourth[0][1] == 2:

            if fourth[0][0] == 0:

                # c.cube_method_mixer("LL")
                c.L()
                c.L()

            if fourth[0][0] == 2:

                # c.cube_method_mixer("DDLL")
                c.D()
                c.D()
                c.L()
                c.L()

    if fourth[0][2] == 2:

        if fourth[0][1] == 0:

            pass

        if fourth[0][1] == 1:

            if fourth[0][0] == 0:

                c.L()
                  
            if fourth[0][0] == 2:

                # c.cube_method_mixer("BdLLb")
                c.B_r()
                c.D()
                c.L()
                c.L()
                c.B()

        if fourth[0][1] == 2:

            # c.cube_method_mixer("dLL")
            c.D()
            c.L()
            c.L()

    if cube_method_good_orient(fourth[2], x, y, z) == True:

        return True
      
    else:

        # c.cube_method_mixer("LLdFLf")
        c.L()
        c.L()
        c.D()
        c.F()
        c.L_r()
        c.F_r()

        return True

def cube_method_firstcorner(c, x=1, y=3, z=6):
    first = cube_method_findcolour(c, x, y, z)
    print(first)
    if first[0][2] == 2:

        if first[0][1] == 0:

            if first[0][0] == 0:

                # c.cube_method_mixer("LDDl")
                c.L()
                c.D()
                c.D()
                c.L_r()
                # c.cube_method_mixer("DrdR")
                c.D()
                c.R_r()
                c.D_r()
                c.R()

            if first[0][0] == 2:

                # c.cube_method_mixer("Rdrdd")
                c.R()
                c.D_r()
                c.R_r()
                c.D_r()
                c.D_r()
                # c.cube_method_mixer("DrdR")
                c.D()
                c.R_r()
                c.D_r()
                c.R()

        if first[0][1] == 2:

            if first[0][0] == 0:

                # c.cube_method_mixer("DD")
                c.D()
                c.D()
                # c.cube_method_mixer("DrdR")
                c.D()
                c.R_r()
                c.D_r()
                c.R()

            if first[0][0] == 2:
              
                c.D()
                # c.cube_method_mixer("DrdR")
                c.D()
                c.R_r()
                c.D_r()
                c.R()

    if first[0][2] == 0:
          
        if first[0][1] == 0:

            if first[0][0] == 0:

                # c.cube_method_mixer("ldL")
                c.L_r()
                c.D_r()
                c.L()
                # c.cube_method_mixer("DrdR")
                c.D()
                c.R_r()
                c.D_r()
                c.R()

            if first[0][0] == 2:

                pass

        if first[0][1] == 2:

            if first[0][0] == 0:
                
                c.D_r()
                # c.cube_method_mixer("DrdR")
                c.D()
                c.R_r()
                c.D_r()
                c.R()

            if first[0][0] == 2:

                # c.cube_method_mixer("DrdR")
                c.D()
                c.R_r()
                c.D_r()
                c.R()

    if cube_method_findcolour(c, x, y, z)[0] == [2, 0, 0]:

        while cube_method_good_orient(first[2], x, y, z)==False:
                print(first[2])
                # c.cube_method_mixer("rDRDDFDf")
                c.R_r()
                c.D()
                c.R()
                c.D()
                c.D()
                c.F()
                c.D()
                c.F_r()
                print(first[2])
        return True

    else:
        print(first)


def cube_method_secondcorner(c, x=5, y=3, z=6):
    second = cube_method_findcolour(c, x, y, z)
    if second[0][2] == 2:

        if second[0][1] == 0:

            if second[0][0] == 0:

                # c.cube_method_mixer("bdB")
                c.B_r()
                c.D_r()
                c.B()
                c.D_r()
                c.L_r()
                c.D()
                c.L()

            if second[0][0] == 2:

                # c.cube_method_mixer("Bddb")
                c.B()
                c.D_r()
                c.D_r()
                c.B_r()
                c.D_r()
                c.L_r()
                c.D()
                c.L()

        if second[0][1] == 2:

            if second[0][0] == 0:

                c.D_r()
                c.D_r()
                c.L_r()
                c.D()
                c.L()

            if second[0][0] == 2:

                # c.cube_method_mixer("DD")
                c.D()
                c.D()
                c.D_r()
                c.L_r()
                c.D()
                c.L()


    if second[0][2] == 0:
          
        if second[0][1] == 0:

            if second[0][0] == 0:

                pass
        
            if second[0][0] == 2:

                pass

        if second[0][1] == 2:

            if second[0][0] == 2:
                # c.cube_method_mixer("lDL")
                c.L_r()
                c.D()
                c.L()
                c.D_r()
                c.L_r()
                c.D()
                c.L()

            if second[0][0] == 0:
                # c.cube_method_mixer("blDL")
                c.D_r()
                c.L_r()
                c.D()
                c.L()

    if cube_method_findcolour(c, x, y, z)[0] == [0, 0, 0]:

        while cube_method_good_orient(second[2], x, y, z) != True:

            # c.cube_method_mixer("lDLdlDL")
            c.L_r()
            c.D()
            c.L()
            c.D_r()
            c.L_r()
            c.D()
            c.L()

        return True

def cube_method_thirdcorner(c, x=5, y=3, z=4):
    third = cube_method_findcolour(c, x, y, z)
    if third[0][2] == 0:
          
        if third[0][1] == 0:

            if third[0][0] == 0:

                pass

            if third[0][0] == 2:

                pass
        
        if third[0][1] == 2:

            if third[0][0] == 0:
                
                c.D()
                c.D_r()
                c.B_r()
                c.D()
                c.B()
                
            if third[0][0] == 2:

                # c.cube_method_mixer("DD")
                c.D()
                c.D()
                c.D_r()
                c.B_r()
                c.D()
                c.B()
    
    if third[0][2] == 2:

        if third[0][1] == 0:

            if third[0][0] == 0:

                pass

            if third[0][0] == 2:

                # c.cube_method_mixer("Rdr")
                c.R()
                c.D_r()
                c.R_r()
                c.D_r()
                c.B_r()
                c.D()
                c.B()

        if third[0][1] == 2:

            if third[0][0] == 2:

                c.D_r()
                c.D_r()
                c.B_r()
                c.D()
                c.B()

            if third[0][0] == 0:

                # c.cube_method_mixer("dbDB")
                c.D_r()
                c.B_r()
                c.D()
                c.B()

    if cube_method_findcolour(c, x, y, z)[0] == [0, 0, 2]:

        while cube_method_good_orient(third[2], x, y, z) != True:
            print(third)
            # c.cube_method_mixer("bDBdbDB")
            c.B_r()
            c.D()
            c.B()
            c.D_r()
            c.B_r()
            c.D()
            c.B()

        return True

def cube_method_fourthcorner(c, x=1, y=3, z=4):
    fourth=cube_method_findcolour(c,x,y,z)
    if fourth[0][2] == 0:
          
        if fourth[0][1] == 0:

            if fourth[0][0] == 0:

                pass

            if fourth[0][0] == 2:

                pass
          
        if fourth[0][1] == 2:

            if fourth[0][0] == 0:

                # c.cube_method_mixer("DD")
                c.D()
                c.D()
                c.D_r()
                c.R()
                c.D()
                c.R_r()
                
            if fourth[0][0] == 2:

                c.D_r()
                c.D_r()
                c.R()
                c.D()
                c.R_r()
    
    if fourth[0][2] == 2:

        if fourth[0][1] == 0:

            if fourth[0][0] == 0:

                pass
              
            if fourth[0][0] == 2:

                pass

        if fourth[0][1] == 2:

            if fourth[0][0] == 0:

                c.D()
                c.D_r()
                c.R()
                c.D()
                c.R_r()

            if fourth[0][0] == 2:
                # c.cube_method_mixer("dRdr")
                c.D_r()
                c.R()
                c.D()
                c.R_r()

    if cube_method_findcolour(c, x, y, z)[0] == [2, 0, 2]:

        while cube_method_good_orient(fourth[2], x, y, z)!=True:
            # c.cube_method_mixer("BDbdBDb")
            c.B()
            c.D()
            c.B_r()
            c.D_r()
            c.B()
            c.D()
            c.B_r()

        return True

def cube_method_middle1(c, x=5, y=-1, z=6):
    c.cube_method_flipper("x")
    c.cube_method_flipper("x")
    c.cube_method_flipper("y")

    first=cube_method_findcolour(c,x,y,z)

    if first[0][1]==1:
  
        if first[0][2]==0:

            if first[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if first[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

        if first[0][2]==2:

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")

            if first[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if first[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")
      
    if first[0][1]==0:

        if first[0][0]==0:

              c.U_r()

        if first[0][0]==1:

            if first[0][2]==1:

                pass
              
            if first[0][2]==2:

                c.U()
                c.U()
          
        if first[0][0]==2:

              c.U()

    c.U()
    c.R()
    c.U_r()
    c.R_r()
    c.U_r()
    c.F_r()
    c.U()
    c.F()

    if cube_method_good_orient(first[2], x, y, z)==True:

            return True
      
    else:

        c.U()
        c.R()
        c.U_r()
        c.R_r()
        c.U_r()
        c.F_r()
        c.U()
        c.F()
        c.U_r()
        c.R()
        c.U_r()
        c.R_r()
        c.U_r()
        c.F_r()
        c.U()
        c.F()
        c.U()

        return True

def cube_method_middle2(c, x=1, y=-1, z=6):
    second=cube_method_findcolour(c,x,y,z)

    if second[0][1]==1:
  
        if second[0][2]==0:

            if second[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if second[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

        if second[0][2]==2:

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")

            if second[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if second[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")
      
    if second[0][1]==0:

        if second[0][0]==0:

            c.U_r()

        if second[0][0]==1:

            if second[0][2]==1:

                  pass
              
            if second[0][2]==2:

                c.U()
                c.U()
          
        if second[0][0]==2:

            c.U()

    c.U_r()
    c.L_r()
    c.U()
    c.L()
    c.U()
    c.F()
    c.U_r()
    c.F_r()

    if cube_method_good_orient(second[2], x, y, z)==True:

            return True
      
    else:

        c.U_r()
        c.L_r()
        c.U()
        c.L()
        c.U()
        c.F()
        c.U_r()
        c.F_r()
        c.U()
        c.L_r()
        c.U()
        c.L()
        c.U()
        c.F()
        c.U_r()
        c.F_r()
        c.U_r()


        return True

def cube_method_middle3(c, x=1, y=-1, z=4):
    c.cube_method_flipper("y")
    c.cube_method_flipper("y")

    third=cube_method_findcolour(c,x,y,z)

    if third[0][1]==1:
  
        if third[0][2]==0:

            if third[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if third[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

        if third[0][2]==2:

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")

            if third[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if third[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")
      
    if third[0][1]==0:

        if third[0][0]==0:

              c.U_r()

        if third[0][0]==1:

            if third[0][2]==1:

                  pass
              
            if third[0][2]==2:

                c.U()
                c.U()
          
        if third[0][0]==2:

              c.U()

    c.U()
    c.R()
    c.U_r()
    c.R_r()
    c.U_r()
    c.F_r()
    c.U()
    c.F()


    if cube_method_good_orient(third[0], x, y, z)==True:

            return True
      
    else:

        c.U()
        c.R()
        c.U_r()
        c.R_r()
        c.U_r()
        c.F_r()
        c.U()
        c.F()
        c.U_r()
        c.R()
        c.U_r()
        c.R_r()
        c.U_r()
        c.F_r()
        c.U()
        c.F()


        return True

def cube_method_middle4(c, x=5, y=-1, z=4):

      second=cube_method_findcolour(c,x,y,z)

      if second[0][1]==1:
  
         if second[0][2]==0:

            if second[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if second[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

         if second[0][2]==2:

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")

            if second[0][0]==0:

                c.U_r()
                c.L_r()
                c.U()
                c.L()
                c.U()
                c.F()
                c.U_r()
                c.F_r()

            if second[0][0]==2:

                c.U()
                c.R()
                c.U_r()
                c.R_r()
                c.U_r()
                c.F_r()
                c.U()
                c.F()

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")
      
      if second[0][1]==0:

          if second[0][0]==0:

              c.U_r()

          if second[0][0]==1:

              if second[0][2]==1:

                  pass
              
              if second[0][2]==2:

                c.U()
                c.U()
          
          if second[0][0]==2:

              c.U()

      c.U_r()
      c.L_r()
      c.U()
      c.L()
      c.U()
      c.F()
      c.U_r()
      c.F_r()

      if cube_method_good_orient(second[0], x, y, z)==True:

            return True
      
      else:

            c.U_r()
            c.L_r()
            c.U()
            c.L()
            c.U()
            c.F()
            c.U_r()
            c.F_r()
            c.U()
            c.L_r()
            c.U()
            c.L()
            c.U()
            c.F()
            c.U_r()
            c.F_r()

            return True

p=['100','201' , '102']
def cube_method_yellow_cross(c, p):
      upperfirstmiddle=cube_method_which_colour(c, p[0])
      uppersecondright=cube_method_which_colour(c, p[1])
      upperbackmiddle=cube_method_which_colour(c, p[2])
      if upperfirstmiddle[2][2]==2:
        
        if uppersecondright[2][2]==2:

          if upperbackmiddle[2][2]==2:

            return True

          else:

            c.U()
            c.U()


            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            return True
        
        else:

          if upperbackmiddle[2][2]==2:

            c.U()

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            return True
         
          else:

            c.U()

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            return True
      else:

        if uppersecondright[2][2]==2:

          if upperbackmiddle[2][2]==2:

            c.U_r()

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()
      
            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            return True

          else:

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            return True

        else:

          if upperbackmiddle[2][2]==2:

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            return True

          else:

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r() 

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            c.F()
            c.R()
            c.U()
            c.R_r()
            c.U_r()
            c.F_r()

            return True

p=['100', '201', '102']
def cube_method_fifth_step1(c, p):
    upperfirstmiddle=cube_method_which_colour(c, p[0])
    uppersecondleft=cube_method_which_colour(c, p[1])
    upperbackmiddle=cube_method_which_colour(c, p[2])
    
    if upperfirstmiddle[2][2]==4:

      return True

    else:

      if uppersecondleft[2][0]==4:

          c.R()
          c.U()
          c.R_r()
          c.U()
          c.R()
          c.U()
          c.U()
          c.R_r()
          c.U()

          return True
      
      else:

         if upperbackmiddle[2][2]==4:

           c.cube_method_flipper("y")
           c.cube_method_flipper("y")

           c.R()
           c.U()
           c.R_r()
           c.U()
           c.R()
           c.U()
           c.U()
           c.R_r()
           c.U()

           c.cube_method_flipper("y")

           c.R()
           c.U()
           c.R_r()
           c.U()
           c.R()
           c.U()
           c.U()
           c.R_r()
           c.U()

           return True

         else:

           c.cube_method_flipper("y")
           c.cube_method_flipper("y")
           c.cube_method_flipper("y")

           c.R()
           c.U()
           c.R_r()
           c.U()
           c.R()
           c.U()
           c.U()
           c.R_r()
           c.U()

           c.cube_method_flipper("y")

           return True

p=['100', '201', '102']
def cube_method_fifth_step2(c, p):
    upperfirstmiddle=cube_method_which_colour(c, p[0])
    uppersecondleft=cube_method_which_colour(c, p[1])
    upperbackmiddle=cube_method_which_colour(c, p[2])

    c.cube_method_flipper("y")
    c.cube_method_flipper("y")
    c.cube_method_flipper("y")
    
    if upperfirstmiddle[2][2]==5:

      return True

    else:

      if uppersecondleft[2][0]==5:

          c.R()
          c.U()
          c.R_r()
          c.U()
          c.R()
          c.U()
          c.U()
          c.R_r()
          c.U()

          return True
      
      else:

           c.cube_method_flipper("y")
           c.cube_method_flipper("y")

           c.L_r()
           c.U_r()
           c.L()
           c.U_r()
           c.L_r()
           c.U_r()
           c.U_r()
           c.L()
           c.U_r()

           c.cube_method_flipper("y")
           c.cube_method_flipper("y")

           c.R()
           c.U()
           c.R_r()
           c.U()
           c.R()
           c.U()
           c.U()
           c.R_r()
           c.U()

           return True


def cube_method_fifth_step3(c, string1='100', string2='201'):
    upperfirstmiddle=cube_method_which_colour(c, string1)
    uppersecondleft=cube_method_which_colour(c, string2)
    c.cube_method_flipper("y")
    c.cube_method_flipper("y")
    c.cube_method_flipper("y")
    
    if upperfirstmiddle[2][2]==6:

      return True

    else:

      if uppersecondleft[2][0]==6:

          c.R()
          c.U()
          c.R_r()
          c.U()
          c.R()
          c.U()
          c.U()
          c.R_r()
          c.U()

          return True
      
      else:

           c.R()
           c.U()
           c.R_r()
           c.U()
           c.R()
           c.U()
           c.U()
           c.R_r()
           c.U()
           
           return True

dict_of_color_num={"R":1, "Y":2,"W":3, "B":4, "O":5, "G":6}
def cube_method_sixth_step(c):
  l0=c.cube_method_get_cubie_pos_name_color()
  sixth1=l0[18][2].sort()
  sixth2=l0[0][2].sort()
  if  sixth1[0]==2 and sixth1[1]==5 and sixth1[2]==6:

    if sixth2[0]==1 and sixth2[1]==2 and sixth2[2]==6:
      
      return True
    
    else: 

      c.U()
      c.R()
      c.U_r()
      c.L_r()
      c.U()
      c.R_r()
      c.U_r()

      l1=c.cube_method_get_cubie_pos_name_color()
      sixth3=l0[0][2].sort()

      if sixth3[0]==1 and sixth3[1]==2 and sixth3[2]==6:

        return True

      else:

        c.U()
        c.R()
        c.U_r()
        c.L_r()
        c.U()
        c.R_r()
        c.U_r()

        return True
  
  else:

     end=False

     while end != True:

        c.cube_method_flipper("y")
        l2=c.cube_method_get_cubie_pos_name_color()
        sixth4=l2[18][2].sort()
        sixth5=l2[0][2].sort()

        if sixth4[0]==2 and sixth4[1]==5 and sixth4[2]==6:

            if sixth5[0]==2 and sixth5[1]==5 and sixth5[2]==6:

                c.cube_method_flipper("y")
                c.cube_method_flipper("y")
                c.cube_method_flipper("y")

                end=True

            else:

                c.U()
                c.R()
                c.U_r()
                c.L_r()
                c.U()
                c.R_r()
                c.U_r()

                l3=c.cube_method_get_cubie_pos_name_color()
                sixth6=l3[0][2].sort()

                if sixth6[0]==2 and sixth6[1]==5 and sixth6[2]==6:

                    c.cube_method_flipper("y")
                    c.cube_method_flipper("y")
                    c.cube_method_flipper("y")

                    end=True

                else:

                    c.U()
                    c.R()
                    c.U_r()
                    c.L_r()
                    c.U()
                    c.R_r()
                    c.U_r()

            c.cube_method_flipper("y")
            c.cube_method_flipper("y")
            c.cube_method_flipper("y")

            end=True

        else:

            c.cube_method_flipper("y")
            l4=c.cube_method_get_cubie_pos_name_color()
            sixth7=l4[18][2].sort()
            sixth8=l4[0][2].sort()
         
            if sixth7[0]==1 and sixth7[1]==2 and sixth7[2]==4:
         
                if sixth8[0]==2 and sixth8[1]==4 and sixth8[2]==5:

                    c.cube_method_flipper("y")
                    c.cube_method_flipper("y")

                    end=True

                else:
            
                    c.U()
                    c.R()
                    c.U_r()
                    c.L_r()
                    c.U()
                    c.R_r()
                    c.U_r()

                    l5=c.cube_method_get_cubie_pos_name_color()
                    sixth9=l5[0][2].sort()

                    if sixth9[0]==2 and sixth9[1]==4 and sixth9[2]==5:

                        c.cube_method_flipper("y")
                        c.cube_method_flipper("y")

                        end=True

                    else:
              
                        c.U()
                        c.R()
                        c.U_r()
                        c.L_r()
                        c.U()
                        c.R_r()
                        c.U_r()

                c.cube_method_flipper("y")
                c.cube_method_flipper("y")

                end=True

            else:

                c.cube_method_flipper("y")

                l6=c.cube_method_get_cubie_pos_name_color()
                sixth10=l6[18][2].sort()
                sixth11=l6[0][2].sort()

                if sixth10[0]==1 and sixth10[1]==2 and sixth10[2]==4:

                    if sixth11[0]==1 and sixth11[1]==2 and sixth11[2]==6:
              
                        c.cube_method_flipper("y")

                        end=True


                    else:

                        c.U()
                        c.R()
                        c.U_r()
                        c.L_r()
                        c.U()
                        c.R_r()
                        c.U_r()

                        l7=c.cube_method_get_cubie_pos_name_color()
                        sixth12=l7[0][2].sort()

                        if sixth12[0]==1 and sixth12[1]==2 and sixth12[2]==6:

                            c.cube_method_flipper("y")

                            end=True

                        else:

                                c.U()
                                c.R()
                                c.U_r()
                                c.L_r()
                                c.U()
                                c.R_r()
                                c.U_r()

                                c.cube_method_flipper("y")

                                end=True
          
                else:

                    c.cube_method_flipper("y")

                    c.U()
                    c.R()
                    c.U_r()
                    c.L_r()
                    c.U()
                    c.R_r()
                    c.U_r()


def cube_method_seventh_step(c):
  counter=0
  while counter<=4:
    if yellow(c):
      
      counter+=1
      c.U()

    else:

      c.R_r()
      c.D_r()
      c.R()
      c.D()

  if counter==4:

    return True


# kellene egy olyan cube_method hogy input : ""
# ,color,facekar
# kell a white közép
# kellenek a közepek
# ezek koordinátái: minden oldalon a középső:1

# az adott pozíción lesz egy string ami a cubie kódja ami ott van
# a dictben ezzel a kóddal érjük el a cubie színeit

# new idea: F-ben tudjuk a fix positiont [1][1][0] itt a cubie.l[2]==F
# van még cubie amire ez igaz?
# addig megy a flip xy amíg ez igaz nem lesz

def adjust_color_middle_to_face(c, middlecolor, side_to_flip_to):
    #c.cube_method_did_cubie_move(facekar)
    list_of_cubie_pos_name_color=c.cube_method_get_cubie_pos_name_color()
    # ebben keresem a közepeket, (ezek amiknek a col ban 2 db -1 és egy col van)
    # ha megvannak elmentem dictben, a colorral együtt
    # ezután forgatom az egész kockát flippel amíg a lekért listában
    # a pos nem az ahova akarom forgatni a kockát
    dict_of_num_color={1: "R", 2:"Y",3:"W", 4:"B", 5:"O", 6:"G"}
    dict_of_color_num={"R":1, "Y":2,"W":3, "B":4, "O":5, "G":6}
    dict_of_middles={}
    for tup in list_of_cubie_pos_name_color:
        if list(tup[2]).count(-1)==2:
            # print(tup)
            for color in tup[2]:
                if color!=-1:
                    dict_of_middles[dict_of_num_color[color]]=tup[0]
    print(dict_of_middles) # dictben van a color és a position
    dict_of_middle_sides={'L': [0, 1, 1], 'U': [1, 0, 1], 'F': [1, 1, 0], 'B': [1, 1, 2], 'D': [1, 2, 1], 'R': [2, 1, 1]}
    steps=["x","x","x","x","y","y","y","y","x","y","y","y","y","x","y","y","y","y","x","y","y","y","y","x","y","y","y","y","y","x","x","x","x","y","x","x","x","x","y","x","x","x","x","y","x","x","x","x"]
    stepper=0
    while dict_of_middles[middlecolor]!=dict_of_middle_sides[side_to_flip_to]:
        c.cube_method_flipper(steps[stepper])
        list_of_cubie_pos_name_color=c.cube_method_get_cubie_pos_name_color()
        dict_of_middles={}
        for tup in list_of_cubie_pos_name_color:
            if list(tup[2]).count(-1)==2:
                # print(tup)
                for color in tup[2]:
                    if color!=-1:
                        dict_of_middles[dict_of_num_color[color]]=tup[0]

        print("stepper: ", stepper)
        print((dict_of_middles))
        print("sides: ")
        print(dict_of_middle_sides)
        stepper+=1
        if stepper>=len(steps):
            print("NOOOO")
            break

    if dict_of_middles[middlecolor]==dict_of_middle_sides[side_to_flip_to]:
        print("TRUE")
    else:
        print("NOT TRUE")
    # minden
    # dictben kell addig újrahívni ezt amíg mondjuk red az U nem lesz
    # ez még lehet cube tulajdonságnak tenni


